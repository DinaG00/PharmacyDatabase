--MONTHLY INVOICE SUMMARY BY PRODUCER: 
DECLARE
    CURSOR C_INVOICE_SUMMARY IS
        SELECT EXTRACT(MONTH FROM G.INVOICE_DATE) AS INVOICE_MONTH, P.PRODUCER_NAME, SUM(G.GRN_VALUE) AS TOTAL_VALUE
        FROM GRN G, PRODUCERS P
        WHERE G.PRODUCER_ID = P.PRODUCER_ID
        GROUP BY EXTRACT(MONTH FROM G.INVOICE_DATE), P.PRODUCER_NAME
        ORDER BY INVOICE_MONTH;
    
    V_INVOICE_MONTH NUMBER;
    V_PRODUCER_NAME PRODUCERS.PRODUCER_NAME%TYPE;
    V_TOTAL_VALUE NUMBER;
BEGIN
    OPEN C_INVOICE_SUMMARY;
    LOOP
        FETCH C_INVOICE_SUMMARY INTO V_INVOICE_MONTH, V_PRODUCER_NAME, V_TOTAL_VALUE;
        EXIT WHEN C_INVOICE_SUMMARY%NOTFOUND;
        
        DBMS_OUTPUT.PUT_LINE('MONTH: ' || V_INVOICE_MONTH || ', PRODUCER: ' || V_PRODUCER_NAME || ', TOTAL VALUE: ' || V_TOTAL_VALUE);
    END LOOP;
    CLOSE C_INVOICE_SUMMARY;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
END;
/

--PRODUCTS EXPIRING BY END OF 2026: 

DECLARE
    CURSOR C_EXPIRING_PRODUCTS IS
        SELECT I.ITEM_NAME, G.EXPIRATION_DATE, SUM(G.QUANTITY) AS TOTAL_QUANTITY
        FROM ITEMS I, GRN_DETAILED G
        WHERE I.ITEM_ID = G.ITEM_ID AND EXTRACT(YEAR FROM G.EXPIRATION_DATE) <= 2026
        GROUP BY I.ITEM_NAME, G.EXPIRATION_DATE;

    V_ITEM_NAME ITEMS.ITEM_NAME%TYPE;
    V_EXPIRATION_DATE GRN_DETAILED.EXPIRATION_DATE%TYPE;
    V_TOTAL_QUANTITY NUMBER;
BEGIN
    OPEN C_EXPIRING_PRODUCTS;
    LOOP
        FETCH C_EXPIRING_PRODUCTS INTO V_ITEM_NAME, V_EXPIRATION_DATE, V_TOTAL_QUANTITY;
        EXIT WHEN C_EXPIRING_PRODUCTS%NOTFOUND;

        DBMS_OUTPUT.PUT_LINE('ITEM NAME: ' || V_ITEM_NAME || ', EXPIRATION DATE: ' || TO_CHAR(V_EXPIRATION_DATE, 'DD-MON-YYYY') || ', TOTAL QUANTITY: ' || V_TOTAL_QUANTITY);
    END LOOP;
    CLOSE C_EXPIRING_PRODUCTS;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
END;
/

--SOLD VALUE FOR EACH PATIENT:
DECLARE
    CURSOR C_PATIENT_SOLD_VALUE IS
        SELECT CONCAT(CONCAT(P.FIRST_NAME, ' '), P.LAST_NAME) AS PATIENT_NAME, SUM(S.SALE_VALUE) AS SOLD_VALUE
        FROM PATIENTS P, SALES S
        WHERE P.ID = S.PATIENT_ID
        GROUP BY P.FIRST_NAME, P.LAST_NAME;

    V_PATIENT_NAME VARCHAR2(100);
    V_SOLD_VALUE NUMBER;
BEGIN
    OPEN C_PATIENT_SOLD_VALUE;
    LOOP
        FETCH C_PATIENT_SOLD_VALUE INTO V_PATIENT_NAME, V_SOLD_VALUE;
        EXIT WHEN C_PATIENT_SOLD_VALUE%NOTFOUND;

        DBMS_OUTPUT.PUT_LINE('PATIENT NAME: ' || V_PATIENT_NAME || ', SOLD VALUE: ' || V_SOLD_VALUE);
    END LOOP;
    CLOSE C_PATIENT_SOLD_VALUE;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
END;
/

--HOW MANY SALES DOES EACH ACTIVE EMPLOYEE HAVE:
BEGIN
    FOR REC IN (
        SELECT COUNT(S.SALE_ID) AS NUMBER_OF_SALE, P.FIRST_NAME || ' ' || P.LAST_NAME AS PHARMACEUTIST_NAME
        FROM SALES S
        JOIN PHARMACEUTIST P ON P.PHARMACEUTIST_ID = S.PHARMACEUTIST_ID
        WHERE P.ACTIVE_STATUS = 'Y'
        GROUP BY P.FIRST_NAME, P.LAST_NAME
    ) LOOP
        DBMS_OUTPUT.PUT_LINE('PHARMACEUTIST NAME: ' || REC.PHARMACEUTIST_NAME || ', NUMBER OF SALES: ' || REC.NUMBER_OF_SALE);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
END;
/

--WHAT DO WE HAVE TO PAY UNTIL THE END OF THE YEAR
DECLARE
    TOTAL_VALUE NUMBER;
BEGIN
    SELECT SUM(GRN_VALUE) 
    INTO TOTAL_VALUE
    FROM GRN
    WHERE PAYMENT_TERM BETWEEN TO_DATE('31-10-2023', 'DD-MM-YYYY') AND TO_DATE('01-01-2024', 'DD-MM-YYYY');

    IF TOTAL_VALUE IS NOT NULL THEN
        DBMS_OUTPUT.PUT_LINE('TOTAL VALUE TO BE PAID UNTIL THE END OF THE YEAR: ' || TOTAL_VALUE);
    ELSE
        DBMS_OUTPUT.PUT_LINE('NO PAYMENTS REQUIRED UNTIL THE END OF THE YEAR.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
END;
/

--ITEMS WITH NO SALES:
DECLARE
    V_ITEM_NAME ITEMS.ITEM_NAME%TYPE;
    V_ITEM_ID GRN_DETAILED.ITEM_ID%TYPE;
    V_COUNTER NUMBER := 0;
BEGIN
    FOR REC IN (
        SELECT I.ITEM_NAME, G.ITEM_ID
        FROM ITEMS I
        JOIN GRN_DETAILED G ON I.ITEM_ID = G.ITEM_ID
        MINUS
        SELECT I.ITEM_NAME, S.ITEM_ID
        FROM ITEMS I
        JOIN SALES_DETAILED S ON I.ITEM_ID = S.ITEM_ID
    ) LOOP
        V_ITEM_NAME := REC.ITEM_NAME;
        V_ITEM_ID := REC.ITEM_ID;
        DBMS_OUTPUT.PUT_LINE('ITEM NAME: ' || V_ITEM_NAME || ', ITEM ID: ' || V_ITEM_ID);
        V_COUNTER := V_COUNTER + 1;
    END LOOP;

    IF V_COUNTER = 0 THEN
        DBMS_OUTPUT.PUT_LINE('NO ITEMS WITH NO SALES FOUND.');
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
END;
/

--ALL THE SALES CONCLUDED BY PHARMACEUTISTS THAT NO LONGER WORK IN THE PHARMACY:
DECLARE
    CURSOR SALES_CURSOR IS
        SELECT S.SALE_ID, S.SALE_DATE, S.SALE_VALUE, P.PHARMACEUTIST_ID, P.FIRST_NAME, P.LAST_NAME, P.ACTIVE_STATUS
        FROM SALES S
        JOIN PHARMACEUTIST P ON S.PHARMACEUTIST_ID = P.PHARMACEUTIST_ID
        WHERE P.ACTIVE_STATUS = 'N';
    V_SALES_ID SALES.SALE_ID%TYPE;
    V_SALE_DATE SALES.SALE_DATE%TYPE;
    V_SALE_VALUE SALES.SALE_VALUE%TYPE;
    V_PHARMACEUTIST_ID PHARMACEUTIST.PHARMACEUTIST_ID%TYPE;
    V_FIRST_NAME PHARMACEUTIST.FIRST_NAME%TYPE;
    V_LAST_NAME PHARMACEUTIST.LAST_NAME%TYPE;
    V_ACTIVE_STATUS PHARMACEUTIST.ACTIVE_STATUS%TYPE;
BEGIN
    OPEN SALES_CURSOR;
    LOOP
        FETCH SALES_CURSOR INTO V_SALES_ID, V_SALE_DATE, V_SALE_VALUE, V_PHARMACEUTIST_ID, V_FIRST_NAME, V_LAST_NAME, V_ACTIVE_STATUS;
        EXIT WHEN SALES_CURSOR%NOTFOUND;

        DBMS_OUTPUT.PUT_LINE('SALE ID: ' || V_SALES_ID || ', SALE DATE: ' || V_SALE_DATE ||
                             ', SALE VALUE: ' || V_SALE_VALUE || ', PHARMACEUTIST ID: ' || V_PHARMACEUTIST_ID ||
                             ', FIRST NAME: ' || V_FIRST_NAME || ', LAST NAME: ' || V_LAST_NAME ||
                             ', ACTIVE STATUS: ' || V_ACTIVE_STATUS);
    END LOOP;

    CLOSE SALES_CURSOR;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
END;
/
SELECT S.*, P.*
FROM SALES S
JOIN PHARMACEUTIST P ON S.PHARMACEUTIST_ID = P.PHARMACEUTIST_ID
WHERE CASE
        WHEN P.ACTIVE_STATUS = 'N' THEN 1
        ELSE 0
      END = 1;

--HOW MANY PRODUCTS DO WE HAVE WITH EACH VAT:
DECLARE
    CURSOR ITEMS_CURSOR IS
        SELECT VAT_PERCENT, COUNT(ITEM_ID) AS NUMBER_ITEMS
        FROM ITEMS
        GROUP BY VAT_PERCENT
        ORDER BY VAT_PERCENT DESC;
    V_VAT_PERCENT ITEMS.VAT_PERCENT%TYPE;
    V_NUMBER_ITEMS NUMBER;
BEGIN
    OPEN ITEMS_CURSOR;
    LOOP
        FETCH ITEMS_CURSOR INTO V_VAT_PERCENT, V_NUMBER_ITEMS;
        EXIT WHEN ITEMS_CURSOR%NOTFOUND;

        DBMS_OUTPUT.PUT_LINE('VAT PERCENT: ' || V_VAT_PERCENT || ', NUMBER OF ITEMS: ' || V_NUMBER_ITEMS);
    END LOOP;

    CLOSE ITEMS_CURSOR;
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
END;
/

-- USING EXECUTE IMMEDIATE:

DECLARE
    V_SQL_STATEMENT VARCHAR2(4000);
BEGIN
    V_SQL_STATEMENT := 'INSERT INTO PRODUCERS VALUES (11, ''SVR LAB'')';
    EXECUTE IMMEDIATE V_SQL_STATEMENT;
    DBMS_OUTPUT.PUT_LINE('DATA INSERTED SUCCESSFULLY.');
END;
/

--INCREASE THE PRICE OF PRODUCT 424 BY 10%
DECLARE
    V_PRODUCT_PRICE NUMBER;
BEGIN
    SELECT PRICE INTO V_PRODUCT_PRICE
    FROM GRN_DETAILED
    WHERE ITEM_ID = 424
    FOR UPDATE;

    V_PRODUCT_PRICE := V_PRODUCT_PRICE * 1.1;
    DBMS_OUTPUT.PUT_LINE('PRODUCT PRICE UPDATED SUCCESSFULLY.');

END;
/

-- CREATE A FUNCTION TO CALCULATE THE VAT AMOUNT FOR A GIVEN PRICE AND VAT PERCENT
CREATE OR REPLACE FUNCTION CALCULATE_VAT_AMOUNT(
    PRICE NUMBER,
    VAT_PERCENT NUMBER
) RETURN NUMBER IS
    VAT_AMOUNT NUMBER;
BEGIN
    VAT_AMOUNT := PRICE * (VAT_PERCENT / 100);
    RETURN VAT_AMOUNT;
END;
/

-- ROW-LEVEL FUNCTION: CALCULATE VAT AMOUNT FOR EACH ITEM AND INSERT INTO A NEW TABLE
DECLARE
    V_ITEM_ID ITEMS.ITEM_ID%TYPE;
    V_PRICE GRN_DETAILED.PRICE%TYPE;
    V_VAT_PERCENT ITEMS.VAT_PERCENT%TYPE;
    V_VAT_AMOUNT NUMBER;
BEGIN
    FOR ITEM_RECORD IN (SELECT I.ITEM_ID, GD.PRICE, I.VAT_PERCENT 
                        FROM ITEMS I, GRN_DETAILED GD
                        WHERE I.ITEM_ID = GD.ITEM_ID) LOOP
        V_ITEM_ID := ITEM_RECORD.ITEM_ID;
        V_PRICE := ITEM_RECORD.PRICE;
        V_VAT_PERCENT := ITEM_RECORD.VAT_PERCENT;

        V_VAT_AMOUNT := CALCULATE_VAT_AMOUNT(V_PRICE, V_VAT_PERCENT);

        INSERT INTO ITEM_VAT_AMOUNTS (ITEM_ID, VAT_AMOUNT)
        VALUES (V_ITEM_ID, V_VAT_AMOUNT);
    END LOOP;
END;
/

-- GROUP-LEVEL FUNCTION: CALCULATE TOTAL VAT AMOUNT FOR EACH PRODUCER
DECLARE
    V_PRODUCER_ID PRODUCERS.PRODUCER_ID%TYPE;
    V_TOTAL_VAT_AMOUNT NUMBER;
BEGIN
    FOR PRODUCER_RECORD IN (SELECT PRODUCER_ID FROM PRODUCERS) LOOP
        V_PRODUCER_ID := PRODUCER_RECORD.PRODUCER_ID;

        SELECT SUM(CALCULATE_VAT_AMOUNT(PRICE, VAT_PERCENT))
        INTO V_TOTAL_VAT_AMOUNT
        FROM ITEMS
        WHERE PRODUCER_ID = V_PRODUCER_ID;

        DBMS_OUTPUT.PUT_LINE('TOTAL VAT AMOUNT FOR PRODUCER ' || V_PRODUCER_ID || ': ' || V_TOTAL_VAT_AMOUNT);
    END LOOP;
END;
/

--DISPLAY THE NAMES OF ALL PRODUCERS: 
DECLARE
    V_PRODUCER_ID PRODUCERS.PRODUCER_ID%TYPE;
    V_PRODUCER_NAME PRODUCERS.PRODUCER_NAME%TYPE;
BEGIN
    V_PRODUCER_ID := 1;

    WHILE V_PRODUCER_ID IS NOT NULL LOOP
        BEGIN
            SELECT PRODUCER_NAME
            INTO V_PRODUCER_NAME
            FROM PRODUCERS
            WHERE PRODUCER_ID = V_PRODUCER_ID;

            DBMS_OUTPUT.PUT_LINE('PRODUCER NAME: ' || V_PRODUCER_NAME);
            
            V_PRODUCER_ID := V_PRODUCER_ID + 1;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                EXIT;
        END;
    END LOOP;
END;
/

--USING AN INDEX-BY TABLE, STORE PATIENT IDS AND THEIR CORRESPONDING NAMES
DECLARE
    TYPE PATIENTINDEXTABLE IS TABLE OF PATIENTS.FIRST_NAME%TYPE INDEX BY PLS_INTEGER;
    V_PATIENT_NAMES PATIENTINDEXTABLE;

    CURSOR PATIENT_CURSOR IS
        SELECT ID, FIRST_NAME
        FROM PATIENTS;
    
    V_PATIENT_REC PATIENT_CURSOR%ROWTYPE;
BEGIN
    OPEN PATIENT_CURSOR;
    LOOP
        FETCH PATIENT_CURSOR INTO V_PATIENT_REC;
        EXIT WHEN PATIENT_CURSOR%NOTFOUND;
        
        V_PATIENT_NAMES(V_PATIENT_REC.ID) := V_PATIENT_REC.FIRST_NAME;
    END LOOP;
    CLOSE PATIENT_CURSOR;
    
    IF V_PATIENT_NAMES.FIRST IS NOT NULL THEN
        FOR I IN V_PATIENT_NAMES.FIRST .. V_PATIENT_NAMES.LAST LOOP
            DBMS_OUTPUT.PUT_LINE('PATIENT ID: ' || I || ', NAME: ' || V_PATIENT_NAMES(I));
        END LOOP;
    ELSE
        DBMS_OUTPUT.PUT_LINE('NO PATIENTS FOUND.');
    END IF;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('NO PATIENTS FOUND.');
END;
/

--NESTED TABLE
DECLARE
    TYPE PRODUCTLIST IS TABLE OF VARCHAR2(100);
    V_PRODUCTS PRODUCTLIST := PRODUCTLIST();
    
    V_INDEX NUMBER;
BEGIN
    V_PRODUCTS.EXTEND(3); 
    V_PRODUCTS(1) := 'PARACETAMOL';
    V_PRODUCTS(2) := 'IBUPROFEN';
    V_PRODUCTS(3) := 'ASPIRIN';

    FOR I IN 1 .. V_PRODUCTS.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('PRODUCT ' || I || ': ' || V_PRODUCTS(I));
    END LOOP;

    V_INDEX := V_PRODUCTS.FIRST;
    WHILE V_INDEX IS NOT NULL LOOP
        IF V_PRODUCTS(V_INDEX) = 'IBUPROFEN' THEN
            DBMS_OUTPUT.PUT_LINE('INDEX OF IBUPROFEN: ' || V_INDEX);
            EXIT;
        END IF;
        V_INDEX := V_PRODUCTS.NEXT(V_INDEX);
    END LOOP;
END;
/

--VARRAY:
DECLARE
    TYPE PRODUCTVARRAY IS VARRAY(3) OF VARCHAR2(100);
    V_PRODUCTS PRODUCTVARRAY;
    
    V_INDEX NUMBER;
BEGIN
    V_PRODUCTS := PRODUCTVARRAY('PARACETAMOL', 'IBUPROFEN', 'ASPIRIN');

    FOR I IN 1 .. V_PRODUCTS.COUNT LOOP
        DBMS_OUTPUT.PUT_LINE('PRODUCT ' || I || ': ' || V_PRODUCTS(I));
    END LOOP;

    FOR I IN V_PRODUCTS.FIRST .. V_PRODUCTS.LAST LOOP
        IF V_PRODUCTS(I) = 'IBUPROFEN' THEN
            DBMS_OUTPUT.PUT_LINE('INDEX OF IBUPROFEN: ' || I);
            EXIT; 
        END IF;
    END LOOP;
END;
/
-- FUNCTION TO CALCULATE TOTAL SALE FOR PATIENT:
CREATE OR REPLACE FUNCTION CALCULATE_TOTAL_SALES(PATIENT_ID NUMBER)
RETURN NUMBER
IS
    TOTAL_SALES NUMBER := 0;
BEGIN
    SELECT SUM(SALE_VALUE)
    INTO TOTAL_SALES
    FROM SALES
    WHERE PATIENT_ID = CALCULATE_TOTAL_SALES.PATIENT_ID;

    RETURN TOTAL_SALES;
END;
/
DECLARE
    TOTAL_SALES NUMBER;
BEGIN
    TOTAL_SALES := CALCULATE_TOTAL_SALES(1);
    DBMS_OUTPUT.PUT_LINE('TOTAL SALES TO PATIENT ID 1: ' || TOTAL_SALES);
END;
/

--FUNCTION TO CHECK EXPIRATION DATE:
CREATE OR REPLACE FUNCTION CHECK_PRODUCT_EXPIRY(PRODUCT_ID NUMBER)
RETURN VARCHAR2
IS
    EXPIRY_STATUS VARCHAR2(10);
BEGIN
    SELECT CASE
               WHEN EXPIRATION_DATE < SYSDATE THEN 'EXPIRED'
               ELSE 'NOT EXPIRED'
           END
    INTO EXPIRY_STATUS
    FROM GRN_DETAILED
    WHERE ITEM_ID = CHECK_PRODUCT_EXPIRY.PRODUCT_ID
    AND ROWNUM = 1;
    RETURN EXPIRY_STATUS;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RETURN 'PRODUCT NOT FOUND';
END;
/
DECLARE
    EXPIRY_STATUS VARCHAR2(20);
BEGIN
    EXPIRY_STATUS := CHECK_PRODUCT_EXPIRY(224);
    DBMS_OUTPUT.PUT_LINE('PRODUCT EXPIRY STATUS: ' || EXPIRY_STATUS);
END;
/

--THE TOTAL VALUE OF GOODS RECEIVED FROM EACH PRODUCER, IN EACH MONTH
CREATE OR REPLACE PROCEDURE GET_MONTHLY_PRODUCER_TOTALS IS
    CURSOR C_GRN IS
        SELECT EXTRACT(MONTH FROM G.INVOICE_DATE) AS INVOICE_MONTH,
               P.PRODUCER_NAME,
               SUM(G.GRN_VALUE) AS TOTAL_VALUE
        FROM GRN G, PRODUCERS P
        WHERE G.PRODUCER_ID = P.PRODUCER_ID
        GROUP BY EXTRACT(MONTH FROM G.INVOICE_DATE), P.PRODUCER_NAME
        ORDER BY INVOICE_MONTH;

    TYPE GRN_RECORD IS RECORD (
        INVOICE_MONTH  NUMBER,
        PRODUCER_NAME  VARCHAR2(100),
        TOTAL_VALUE    NUMBER
    );

    V_GRN_RECORD GRN_RECORD;
BEGIN
    OPEN C_GRN;

    LOOP
        FETCH C_GRN INTO V_GRN_RECORD;
        EXIT WHEN C_GRN%NOTFOUND;

        DBMS_OUTPUT.PUT_LINE('MONTH: ' || V_GRN_RECORD.INVOICE_MONTH || 
                             ', PRODUCER: ' || V_GRN_RECORD.PRODUCER_NAME || 
                             ', TOTAL VALUE: ' || V_GRN_RECORD.TOTAL_VALUE);
    END LOOP;

    CLOSE C_GRN;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('NO DATA FOUND.');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
END;
/
BEGIN
    GET_MONTHLY_PRODUCER_TOTALS;
END;

--DELETE A PATIENT PROCEDURE:
CREATE OR REPLACE PROCEDURE DELETE_PATIENT(
    P_PATIENT_ID NUMBER
)
IS
BEGIN
    DELETE FROM PATIENTS
    WHERE ID = P_PATIENT_ID;
END DELETE_PATIENT;
/

--PROCEDURE TO INSERT NEW SALE
CREATE OR REPLACE PROCEDURE INSERT_SALE(
    P_SALE_ID OUT NUMBER,
    P_SALE_DATE DATE,
    P_SALE_VALUE NUMBER,
    P_PAID_STATUS VARCHAR2,
    P_PATIENT_ID NUMBER,
    P_PHARMACEUTIST_ID NUMBER
)
IS
BEGIN
    INSERT INTO SALES (SALE_DATE, SALE_VALUE, FISCAL_RECEIPT_PRINTED, PATIENT_ID, PHARMACEUTIST_ID)
    VALUES (P_SALE_DATE, P_SALE_VALUE, P_PAID_STATUS, P_PATIENT_ID, P_PHARMACEUTIST_ID)
    RETURNING SALE_ID INTO P_SALE_ID;
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('SALE INSERTED SUCCESSFULLY. SALE ID: ' || P_SALE_ID);
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        DBMS_OUTPUT.PUT_LINE('DUPLICATE SALE ID DETECTED. ROLLBACK PERFORMED.');
        ROLLBACK; 
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
        ROLLBACK;
END INSERT_SALE;
/

--PRODUCER PACKAGE:
CREATE OR REPLACE PACKAGE PRODUCERS_PKG IS
    -- PROCEDURE TO INSERT A NEW PRODUCER
    PROCEDURE INSERT_PRODUCER(
        P_PRODUCER_ID IN NUMBER,
        P_PRODUCER_NAME IN VARCHAR2
    );

    -- PROCEDURE TO UPDATE A PRODUCER'S INFORMATION
    PROCEDURE UPDATE_PRODUCER(
        P_PRODUCER_ID IN NUMBER,
        P_NEW_PRODUCER_NAME IN VARCHAR2
    );

    -- PROCEDURE TO DELETE A PRODUCER
    PROCEDURE DELETE_PRODUCER(
        P_PRODUCER_ID IN NUMBER
    );

    -- FUNCTION TO RETRIEVE INFORMATION ABOUT A SPECIFIC PRODUCER
    FUNCTION GET_PRODUCER_INFO(
        P_PRODUCER_ID IN NUMBER
    ) RETURN PRODUCERS%ROWTYPE;

    -- FUNCTION TO RETRIEVE THE TOTAL NUMBER OF PRODUCERS
    FUNCTION GET_PRODUCER_COUNT RETURN NUMBER;
END PRODUCERS_PKG;
/

CREATE OR REPLACE PACKAGE BODY PRODUCERS_PKG IS
    -- PROCEDURE TO INSERT A NEW PRODUCER
    PROCEDURE INSERT_PRODUCER(
        P_PRODUCER_ID IN NUMBER,
        P_PRODUCER_NAME IN VARCHAR2
    ) IS
    BEGIN
        INSERT INTO PRODUCERS (PRODUCER_ID, PRODUCER_NAME)
        VALUES (P_PRODUCER_ID, P_PRODUCER_NAME);
        COMMIT;
    END INSERT_PRODUCER;

    -- PROCEDURE TO UPDATE A PRODUCER'S INFORMATION
    PROCEDURE UPDATE_PRODUCER(
        P_PRODUCER_ID IN NUMBER,
        P_NEW_PRODUCER_NAME IN VARCHAR2
    ) IS
    BEGIN
        UPDATE PRODUCERS
        SET PRODUCER_NAME = P_NEW_PRODUCER_NAME
        WHERE PRODUCER_ID = P_PRODUCER_ID;
        COMMIT;
    END UPDATE_PRODUCER;

    -- PROCEDURE TO DELETE A PRODUCER
    PROCEDURE DELETE_PRODUCER(
        P_PRODUCER_ID IN NUMBER
    ) IS
    BEGIN
        DELETE FROM PRODUCERS WHERE PRODUCER_ID = P_PRODUCER_ID;
        COMMIT;
    END DELETE_PRODUCER;

    -- FUNCTION TO RETRIEVE INFORMATION ABOUT A SPECIFIC PRODUCER
    FUNCTION GET_PRODUCER_INFO(
        P_PRODUCER_ID IN NUMBER
    ) RETURN PRODUCERS%ROWTYPE IS
        V_PRODUCER_INFO PRODUCERS%ROWTYPE;
    BEGIN
        SELECT * INTO V_PRODUCER_INFO
        FROM PRODUCERS
        WHERE PRODUCER_ID = P_PRODUCER_ID;
        RETURN V_PRODUCER_INFO;
    END GET_PRODUCER_INFO;

    -- FUNCTION TO RETRIEVE THE TOTAL NUMBER OF PRODUCERS
    FUNCTION GET_PRODUCER_COUNT RETURN NUMBER IS
        V_COUNT NUMBER;
    BEGIN
        SELECT COUNT(*) INTO V_COUNT FROM PRODUCERS;
        RETURN V_COUNT;
    END GET_PRODUCER_COUNT;
END PRODUCERS_PKG;
/

--PACKAGE FOR DISEASE:

CREATE OR REPLACE PACKAGE DISEASE_PKG IS
    -- FUNCTION TO INSERT A NEW DISEASE AND RETURN THE INSERTED DISEASE'S ID
    FUNCTION INSERT_DISEASE(
        P_DISEASE_NAME IN VARCHAR2
    ) RETURN NUMBER;

    -- PROCEDURE TO UPDATE A DISEASE'S INFORMATION
    PROCEDURE UPDATE_DISEASE_NAME(
        P_DISEASE_ID IN NUMBER,
        P_NEW_DISEASE_NAME IN VARCHAR2
    );

    -- PROCEDURE TO DELETE A DISEASE
    PROCEDURE DELETE_DISEASE(
        P_DISEASE_ID IN NUMBER
    );
END DISEASE_PKG;
/

CREATE OR REPLACE PACKAGE BODY DISEASE_PKG IS
    -- FUNCTION TO INSERT A NEW DISEASE AND RETURN THE INSERTED DISEASE'S ID
    FUNCTION INSERT_DISEASE(
        P_DISEASE_NAME IN VARCHAR2
    ) RETURN NUMBER IS
        V_DISEASE_ID NUMBER;
    BEGIN
        SELECT MAX(DISEASE_ID) + 1 INTO V_DISEASE_ID FROM DISEASE;
        INSERT INTO DISEASE (DISEASE_ID, DISEASE_NAME) VALUES (V_DISEASE_ID, P_DISEASE_NAME);
        COMMIT;
        RETURN V_DISEASE_ID;
    END INSERT_DISEASE;

    -- PROCEDURE TO UPDATE A DISEASE'S INFORMATION
    PROCEDURE UPDATE_DISEASE_NAME(
        P_DISEASE_ID IN NUMBER,
        P_NEW_DISEASE_NAME IN VARCHAR2
    ) IS
    BEGIN
        UPDATE DISEASE
        SET DISEASE_NAME = P_NEW_DISEASE_NAME
        WHERE DISEASE_ID = P_DISEASE_ID;
        COMMIT;
    END UPDATE_DISEASE_NAME;

    -- PROCEDURE TO DELETE A DISEASE
    PROCEDURE DELETE_DISEASE(
        P_DISEASE_ID IN NUMBER
    ) IS
    BEGIN
        DELETE FROM DISEASE WHERE DISEASE_ID = P_DISEASE_ID;
        COMMIT;
    END DELETE_DISEASE;
END DISEASE_PKG;
/

--TRIGGER TO ENFORCE BUSINESS RULES ON SALES TABLE:
CREATE OR REPLACE TRIGGER CHECK_SALE_AMOUNT
BEFORE INSERT OR UPDATE ON SALES
FOR EACH ROW
DECLARE
    V_MAX_SALE_AMOUNT NUMBER := 10000; -- MAXIMUM ALLOWED SALE AMOUNT
BEGIN
    IF :NEW.SALE_VALUE > V_MAX_SALE_AMOUNT THEN
        RAISE_APPLICATION_ERROR(-20001, 'SALE VALUE EXCEEDS MAXIMUM ALLOWED AMOUNT');
    END IF;
END;
/ 